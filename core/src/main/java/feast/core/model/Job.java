/*
 * SPDX-License-Identifier: Apache-2.0
 * Copyright 2018-2019 The Feast Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package feast.core.model;

import com.google.auto.value.AutoValue;
import feast.common.models.FeatureSetReference;
import feast.proto.core.*;
import java.util.*;

/** Contains information about a run job. */
@AutoValue
public abstract class Job {
  private Date created;
  private Date lastUpdated;

  private String extId;
  private JobStatus status = JobStatus.UNKNOWN;

  // Internal job name. Generated by feast ingestion upon invocation.
  public abstract String getId();

  // External job id, generated by the runner and retrieved by feast.
  // Used internally for job management.
  public String getExtId() {
    return extId;
  }

  public JobStatus getStatus() {
    return status;
  }

  // Source type and config, derived from job's source and stored as inline fields.
  public abstract SourceProto.Source getSource();

  // Sinks
  public abstract Map<String, StoreProto.Store> getStores();

  // Allocated FeatureSets' delivery statuses
  public abstract Map<FeatureSetReference, FeatureSetDeliveryStatus>
      getFeatureSetDeliveryStatuses();

  // Job's labels
  public abstract Map<String, String> getLabels();

  public static Builder builder() {
    return new AutoValue_Job.Builder()
        .setFeatureSetDeliveryStatuses(new HashMap<>())
        .setStores(new HashMap<>())
        .setLabels(new HashMap<>());
  }

  @AutoValue.Builder
  public interface Builder {
    Builder setId(String id);

    Builder setSource(SourceProto.Source source);

    Builder setStores(Map<String, StoreProto.Store> stores);

    Builder setFeatureSetDeliveryStatuses(
        Map<FeatureSetReference, FeatureSetDeliveryStatus> statuses);

    Builder setLabels(Map<String, String> labels);

    Job build();
  }

  public Date getCreated() {
    return created;
  }

  public Date getLastUpdated() {
    return lastUpdated;
  }

  public void preSave() {
    if (created == null) {
      created = new Date();
    }
    lastUpdated = new Date();
  }

  public void setExtId(String extId) {
    this.extId = extId;
  }

  public void setStatus(JobStatus status) {
    this.status = status;
  }

  public boolean hasTerminated() {
    return getStatus().isTerminal();
  }

  public boolean isRunning() {
    return getStatus() == JobStatus.RUNNING;
  }

  public boolean isDeployed() {
    return getExtId() != null && !getExtId().isEmpty();
  }

  public void addAllStores(Set<StoreProto.Store> stores) {
    for (var store : stores) {
      this.getStores().put(store.getName(), store);
    }
  }

  public void addAllFeatureSets(Set<FeatureSetProto.FeatureSet> featureSets) {
    for (FeatureSetProto.FeatureSet fs : featureSets) {
      FeatureSetDeliveryStatus status = new FeatureSetDeliveryStatus();
      FeatureSetReference ref =
          FeatureSetReference.of(fs.getSpec().getProject(), fs.getSpec().getName());
      status.setFeatureSetReference(ref);

      if (fs.getMeta().getStatus() == FeatureSetProto.FeatureSetStatus.STATUS_READY) {
        // Feature Set was already delivered to previous generation of the job
        // (another words, it exists in kafka)
        // so we expect Job will ack latest version based on history from kafka topic
        status.setDeliveredVersion(fs.getSpec().getVersion());
      }
      status.setDeliveryStatus(FeatureSetProto.FeatureSetJobDeliveryStatus.STATUS_IN_PROGRESS);
      this.getFeatureSetDeliveryStatuses().put(ref, status);
    }
  }

  /**
   * Convert a job model to ingestion job proto
   *
   * @return Ingestion Job proto derieved from the given job
   */
  public IngestionJobProto.IngestionJob toProto() {

    // convert featuresets of job to protos
    List<FeatureSetReferenceProto.FeatureSetReference> featureSetReferences = new ArrayList<>();

    for (FeatureSetReference featureSetReference : this.getFeatureSetDeliveryStatuses().keySet()) {
      featureSetReferences.add(
          FeatureSetReferenceProto.FeatureSetReference.newBuilder()
              .setName(featureSetReference.getFeatureSetName())
              .setProject(featureSetReference.getProjectName())
              .build());
    }

    // build ingestion job proto with job data
    IngestionJobProto.IngestionJob ingestJob =
        IngestionJobProto.IngestionJob.newBuilder()
            .setId(this.getId())
            .setExternalId(this.getExtId())
            .setStatus(this.getStatus().toProto())
            .setSource(this.getSource())
            .addAllStores(new HashSet<>(this.getStores().values()))
            .addAllFeatureSetReferences(featureSetReferences)
            .build();

    return ingestJob;
  }

  public Job cloneWithIdAndLabels(String newJobId, Map<String, String> labels) {
    return Job.builder()
        .setSource(this.getSource())
        .setFeatureSetDeliveryStatuses(new HashMap<>(this.getFeatureSetDeliveryStatuses()))
        .setStores(new HashMap<>(this.getStores()))
        .setId(newJobId)
        .setLabels(labels)
        .build();
  }

  @Override
  public int hashCode() {
    return Objects.hash(getSource(), getStores());
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj) return true;
    if (!super.equals(obj)) return false;
    if (getClass() != obj.getClass()) return false;
    Job other = (Job) obj;
    if (!this.getSource().equals(other.getSource())) {
      return false;
    } else if (!this.getStores().equals(other.getStores())) {
      return false;
    }
    return true;
  }
}
