import copy
import functools
import inspect
import warnings
from types import FunctionType
from typing import Any, List, Optional, Union, get_type_hints

import dill
import pandas as pd
import pyarrow
from typeguard import typechecked

from feast.base_feature_view import BaseFeatureView
from feast.data_source import RequestSource
from feast.entity import Entity
from feast.errors import RegistryInferenceFailure, SpecifiedFeaturesNotPresentError
from feast.feature_view import DUMMY_ENTITY_NAME, FeatureView
from feast.feature_view_projection import FeatureViewProjection
from feast.field import Field, from_value_type
from feast.protos.feast.core.OnDemandFeatureView_pb2 import (
    OnDemandFeatureView as OnDemandFeatureViewProto,
)
from feast.protos.feast.core.OnDemandFeatureView_pb2 import (
    OnDemandFeatureViewMeta,
    OnDemandFeatureViewSpec,
    OnDemandSource,
)
from feast.protos.feast.core.Transformation_pb2 import (
    FeatureTransformationV2 as FeatureTransformationProto,
)
from feast.protos.feast.core.Transformation_pb2 import (
    UserDefinedFunctionV2 as UserDefinedFunctionProto,
)
from feast.transformation.pandas_transformation import PandasTransformation
from feast.transformation.python_transformation import PythonTransformation
from feast.transformation.substrait_transformation import SubstraitTransformation
from feast.utils import _utc_now
from feast.value_type import ValueType

warnings.simplefilter("once", DeprecationWarning)


@typechecked
class OnDemandFeatureView(BaseFeatureView):
    """
    [Experimental] An OnDemandFeatureView defines a logical group of features that are
    generated by applying a transformation on a set of input sources, such as feature
    views and request data sources.

    Attributes:
        name: The unique name of the on demand feature view.
        features: The list of features in the output of the on demand feature view.
        source_feature_view_projections: A map from input source names to actual input
            sources with type FeatureViewProjection.
        source_request_sources: A map from input source names to the actual input
            sources with type RequestSource.
        feature_transformation: The user defined transformation.
        description: A human-readable description.
        tags: A dictionary of key-value pairs to store arbitrary metadata.
        owner: The owner of the on demand feature view, typically the email of the primary
            maintainer.
    """

    name: str
    entities: Optional[List[str]]
    features: List[Field]
    source_feature_view_projections: dict[str, FeatureViewProjection]
    source_request_sources: dict[str, RequestSource]
    feature_transformation: Union[
        PandasTransformation, PythonTransformation, SubstraitTransformation
    ]
    mode: str
    description: str
    tags: dict[str, str]
    owner: str
    write_to_online_store: bool
    singleton: bool

    def __init__(  # noqa: C901
        self,
        *,
        name: str,
        entities: Optional[List[Entity]] = None,
        schema: Optional[List[Field]] = None,
        sources: List[
            Union[
                FeatureView,
                RequestSource,
                FeatureViewProjection,
            ]
        ],
        udf: Optional[FunctionType] = None,
        udf_string: str = "",
        feature_transformation: Union[
            PandasTransformation, PythonTransformation, SubstraitTransformation
        ],
        mode: str = "pandas",
        description: str = "",
        tags: Optional[dict[str, str]] = None,
        owner: str = "",
        write_to_online_store: bool = False,
        singleton: bool = False,
    ):
        """
        Creates an OnDemandFeatureView object.

        Args:
            name: The unique name of the on demand feature view.
            entities (optional): The list of names of entities that this feature view is associated with.
            schema: The list of features in the output of the on demand feature view, after
                the transformation has been applied.
            sources: A map from input source names to the actual input sources, which may be
                feature views, or request data sources. These sources serve as inputs to the udf,
                which will refer to them by name.
            udf (deprecated): The user defined transformation function, which must take pandas
                dataframes as inputs.
            udf_string (deprecated): The source code version of the udf (for diffing and displaying in Web UI)
            feature_transformation: The user defined transformation.
            mode: Mode of execution (e.g., Pandas or Python native)
            description (optional): A human-readable description.
            tags (optional): A dictionary of key-value pairs to store arbitrary metadata.
            owner (optional): The owner of the on demand feature view, typically the email
                of the primary maintainer.
            write_to_online_store (optional): A boolean that indicates whether to write the on demand feature view to
            the online store for faster retrieval.
            singleton (optional): A boolean that indicates whether the transformation is executed on a singleton
                (only applicable when mode="python").
        """
        super().__init__(
            name=name,
            features=schema,
            description=description,
            tags=tags,
            owner=owner,
        )

        schema = schema or []
        self.entities = [e.name for e in entities] if entities else [DUMMY_ENTITY_NAME]
        self.mode = mode.lower()

        if self.mode not in {"python", "pandas", "substrait"}:
            raise ValueError(
                f"Unknown mode {self.mode}. OnDemandFeatureView only supports python or pandas UDFs and substrait."
            )

        if not feature_transformation:
            if udf:
                warnings.warn(
                    "udf and udf_string parameters are deprecated. Please use transformation=PandasTransformation(udf, udf_string) instead.",
                    DeprecationWarning,
                )
                # Note inspecting the return signature won't work with isinstance so this is the best alternative
                if self.mode == "pandas":
                    feature_transformation = PandasTransformation(udf, udf_string)
                elif self.mode == "python":
                    feature_transformation = PythonTransformation(udf, udf_string)
            else:
                raise ValueError(
                    "OnDemandFeatureView needs to be initialized with either feature_transformation or udf arguments"
                )

        self.source_feature_view_projections: dict[str, FeatureViewProjection] = {}
        self.source_request_sources: dict[str, RequestSource] = {}
        for odfv_source in sources:
            if isinstance(odfv_source, RequestSource):
                self.source_request_sources[odfv_source.name] = odfv_source
            elif isinstance(odfv_source, FeatureViewProjection):
                self.source_feature_view_projections[odfv_source.name] = odfv_source

            else:
                self.source_feature_view_projections[odfv_source.name] = (
                    odfv_source.projection
                )

        features: List[Field] = []
        self.entity_columns = []

        join_keys: List[str] = []
        if entities:
            for entity in entities:
                join_keys.append(entity.join_key)
        # Ensure that entities have unique join keys.
        if len(set(join_keys)) < len(join_keys):
            raise ValueError(
                "A feature view should not have entities that share a join key."
            )

        for field in schema:
            if field.name in join_keys:
                self.entity_columns.append(field)

                # Confirm that the inferred type matches the specified entity type, if it exists.
                matching_entities = (
                    [e for e in entities if e.join_key == field.name]
                    if entities
                    else []
                )
                assert len(matching_entities) == 1
                entity = matching_entities[0]
                if entity.value_type != ValueType.UNKNOWN:
                    if from_value_type(entity.value_type) != field.dtype:
                        raise ValueError(
                            f"Entity {entity.name} has type {entity.value_type}, which does not match the inferred type {field.dtype}."
                        )
            else:
                features.append(field)

        self.features = features
        self.feature_transformation = feature_transformation
        self.write_to_online_store = write_to_online_store
        self.singleton = singleton
        if self.singleton and self.mode != "python":
            raise ValueError("Singleton is only supported for Python mode.")

    @property
    def proto_class(self) -> type[OnDemandFeatureViewProto]:
        return OnDemandFeatureViewProto

    def __copy__(self):
        fv = OnDemandFeatureView(
            name=self.name,
            schema=self.features,
            sources=list(self.source_feature_view_projections.values())
            + list(self.source_request_sources.values()),
            feature_transformation=self.feature_transformation,
            mode=self.mode,
            description=self.description,
            tags=self.tags,
            owner=self.owner,
            write_to_online_store=self.write_to_online_store,
            singleton=self.singleton,
        )
        fv.entities = self.entities
        fv.features = self.features
        fv.projection = copy.copy(self.projection)
        fv.entity_columns = copy.copy(self.entity_columns)

        return fv

    def __eq__(self, other):
        if not isinstance(other, OnDemandFeatureView):
            raise TypeError(
                "Comparisons should only involve OnDemandFeatureView class objects."
            )

        # Note, no longer evaluating the base feature view layer as ODFVs can have
        # multiple datasources and a base_feature_view only has one source
        # though maybe that shouldn't be true
        if (
            self.source_feature_view_projections
            != other.source_feature_view_projections
            or self.description != other.description
            or self.source_request_sources != other.source_request_sources
            or self.mode != other.mode
            or self.feature_transformation != other.feature_transformation
            or self.write_to_online_store != other.write_to_online_store
            or sorted(self.entity_columns) != sorted(other.entity_columns)
            or self.singleton != other.singleton
        ):
            return False

        return True

    @property
    def join_keys(self) -> List[str]:
        """Returns a list of all the join keys."""
        return [entity.name for entity in self.entity_columns]

    @property
    def schema(self) -> List[Field]:
        return list(set(self.entity_columns + self.features))

    def ensure_valid(self):
        """
        Validates the state of this feature view locally.

        Raises:
            ValueError: The On Demand feature view does not have an entity when trying to use write_to_online_store.
        """
        super().ensure_valid()

        if self.write_to_online_store and not self.entities:
            raise ValueError(
                "On Demand Feature views require an entity if write_to_online_store=True"
            )

    def __hash__(self):
        return super().__hash__()

    def to_proto(self) -> OnDemandFeatureViewProto:
        """
        Converts an on demand feature view object to its protobuf representation.

        Returns:
            A OnDemandFeatureViewProto protobuf.
        """
        meta = OnDemandFeatureViewMeta()
        if self.created_timestamp:
            meta.created_timestamp.FromDatetime(self.created_timestamp)
        if self.last_updated_timestamp:
            meta.last_updated_timestamp.FromDatetime(self.last_updated_timestamp)
        sources = {}
        for source_name, fv_projection in self.source_feature_view_projections.items():
            sources[source_name] = OnDemandSource(
                feature_view_projection=fv_projection.to_proto(),
            )
        for (
            source_name,
            request_sources,
        ) in self.source_request_sources.items():
            sources[source_name] = OnDemandSource(
                request_data_source=request_sources.to_proto()
            )

        feature_transformation = FeatureTransformationProto(
            user_defined_function=self.feature_transformation.to_proto()
            if isinstance(
                self.feature_transformation,
                (PandasTransformation, PythonTransformation),
            )
            else None,
            substrait_transformation=self.feature_transformation.to_proto()
            if isinstance(self.feature_transformation, SubstraitTransformation)
            else None,
        )
        spec = OnDemandFeatureViewSpec(
            name=self.name,
            entities=self.entities if self.entities else None,
            entity_columns=[
                field.to_proto() for field in self.entity_columns if self.entity_columns
            ],
            features=[feature.to_proto() for feature in self.features],
            sources=sources,
            feature_transformation=feature_transformation,
            mode=self.mode,
            description=self.description,
            tags=self.tags,
            owner=self.owner,
            write_to_online_store=self.write_to_online_store,
            singleton=self.singleton if self.singleton else False,
        )

        return OnDemandFeatureViewProto(spec=spec, meta=meta)

    @classmethod
    def from_proto(
        cls,
        on_demand_feature_view_proto: OnDemandFeatureViewProto,
        skip_udf: bool = False,
    ):
        """
        Creates an on demand feature view from a protobuf representation.

        Args:
            on_demand_feature_view_proto: A protobuf representation of an on-demand feature view.
            skip_udf: A boolean indicating whether to skip loading the udf

        Returns:
            A OnDemandFeatureView object based on the on-demand feature view protobuf.
        """
        sources = []
        for (
            _,
            on_demand_source,
        ) in on_demand_feature_view_proto.spec.sources.items():
            if on_demand_source.WhichOneof("source") == "feature_view":
                sources.append(
                    FeatureView.from_proto(on_demand_source.feature_view).projection
                )
            elif on_demand_source.WhichOneof("source") == "feature_view_projection":
                sources.append(
                    FeatureViewProjection.from_proto(
                        on_demand_source.feature_view_projection
                    )
                )
            else:
                sources.append(
                    RequestSource.from_proto(on_demand_source.request_data_source)
                )

        if (
            on_demand_feature_view_proto.spec.feature_transformation.WhichOneof(
                "transformation"
            )
            == "user_defined_function"
            and on_demand_feature_view_proto.spec.feature_transformation.user_defined_function.body_text
            != ""
            and on_demand_feature_view_proto.spec.mode == "pandas"
        ):
            transformation = PandasTransformation.from_proto(
                on_demand_feature_view_proto.spec.feature_transformation.user_defined_function
            )
        elif (
            on_demand_feature_view_proto.spec.feature_transformation.WhichOneof(
                "transformation"
            )
            == "user_defined_function"
            and on_demand_feature_view_proto.spec.feature_transformation.user_defined_function.body_text
            != ""
            and on_demand_feature_view_proto.spec.mode == "python"
        ):
            transformation = PythonTransformation.from_proto(
                on_demand_feature_view_proto.spec.feature_transformation.user_defined_function
            )
        elif (
            on_demand_feature_view_proto.spec.feature_transformation.WhichOneof(
                "transformation"
            )
            == "substrait_transformation"
        ):
            transformation = SubstraitTransformation.from_proto(
                on_demand_feature_view_proto.spec.feature_transformation.substrait_transformation
            )
        elif (
            hasattr(on_demand_feature_view_proto.spec, "user_defined_function")
            and on_demand_feature_view_proto.spec.feature_transformation.user_defined_function.body_text
            == ""
        ):
            backwards_compatible_udf = UserDefinedFunctionProto(
                name=on_demand_feature_view_proto.spec.user_defined_function.name,
                body=on_demand_feature_view_proto.spec.user_defined_function.body,
                body_text=on_demand_feature_view_proto.spec.user_defined_function.body_text,
            )
            transformation = PandasTransformation.from_proto(
                user_defined_function_proto=backwards_compatible_udf,
            )
        else:
            raise ValueError("At least one transformation type needs to be provided")

        if hasattr(on_demand_feature_view_proto.spec, "write_to_online_store"):
            write_to_online_store = (
                on_demand_feature_view_proto.spec.write_to_online_store
            )
        else:
            write_to_online_store = False
        if hasattr(on_demand_feature_view_proto.spec, "entities"):
            entities = list(on_demand_feature_view_proto.spec.entities)
        else:
            entities = []
        if hasattr(on_demand_feature_view_proto.spec, "entity_columns"):
            entity_columns = [
                Field.from_proto(field_proto)
                for field_proto in on_demand_feature_view_proto.spec.entity_columns
            ]
        else:
            entity_columns = []
        singleton = False
        if hasattr(on_demand_feature_view_proto.spec, "singleton"):
            singleton = on_demand_feature_view_proto.spec.singleton

        on_demand_feature_view_obj = cls(
            name=on_demand_feature_view_proto.spec.name,
            schema=[
                Field(
                    name=feature.name,
                    dtype=from_value_type(ValueType(feature.value_type)),
                )
                for feature in on_demand_feature_view_proto.spec.features
            ],
            sources=sources,
            feature_transformation=transformation,
            mode=on_demand_feature_view_proto.spec.mode or "pandas",
            description=on_demand_feature_view_proto.spec.description,
            tags=dict(on_demand_feature_view_proto.spec.tags),
            owner=on_demand_feature_view_proto.spec.owner,
            write_to_online_store=write_to_online_store,
            singleton=singleton,
        )

        on_demand_feature_view_obj.entities = entities
        on_demand_feature_view_obj.entity_columns = entity_columns

        # FeatureViewProjections are not saved in the OnDemandFeatureView proto.
        # Create the default projection.
        on_demand_feature_view_obj.projection = FeatureViewProjection.from_definition(
            on_demand_feature_view_obj
        )

        if on_demand_feature_view_proto.meta.HasField("created_timestamp"):
            on_demand_feature_view_obj.created_timestamp = (
                on_demand_feature_view_proto.meta.created_timestamp.ToDatetime()
            )
        if on_demand_feature_view_proto.meta.HasField("last_updated_timestamp"):
            on_demand_feature_view_obj.last_updated_timestamp = (
                on_demand_feature_view_proto.meta.last_updated_timestamp.ToDatetime()
            )

        return on_demand_feature_view_obj

    def get_request_data_schema(self) -> dict[str, ValueType]:
        schema: dict[str, ValueType] = {}
        for request_source in self.source_request_sources.values():
            if isinstance(request_source.schema, list):
                new_schema = {}
                for field in request_source.schema:
                    new_schema[field.name] = field.dtype.to_value_type()
                schema.update(new_schema)
            elif isinstance(request_source.schema, dict):
                schema.update(request_source.schema)
            else:
                raise TypeError(
                    f"Request source schema is not correct type: ${str(type(request_source.schema))}"
                )
        return schema

    def _get_projected_feature_name(self, feature: str) -> str:
        return f"{self.projection.name_to_use()}__{feature}"

    def transform_ibis(
        self,
        ibis_table,
        full_feature_names: bool = False,
    ):
        from ibis.expr.types import Table

        if not isinstance(ibis_table, Table):
            raise TypeError("transform_ibis only accepts ibis.expr.types.Table")

        if not isinstance(self.feature_transformation, SubstraitTransformation):
            raise TypeError(
                "The feature_transformation is not SubstraitTransformation type while calling transform_ibis()."
            )

        columns_to_cleanup = []
        for source_fv_projection in self.source_feature_view_projections.values():
            for feature in source_fv_projection.features:
                full_feature_ref = f"{source_fv_projection.name}__{feature.name}"
                if full_feature_ref in ibis_table.columns:
                    # Make sure the partial feature name is always present
                    ibis_table = ibis_table.mutate(
                        **{feature.name: ibis_table[full_feature_ref]}
                    )
                    columns_to_cleanup.append(feature.name)
                elif feature.name in ibis_table.columns:
                    ibis_table = ibis_table.mutate(
                        **{full_feature_ref: ibis_table[feature.name]}
                    )
                    columns_to_cleanup.append(full_feature_ref)

        transformed_table = self.feature_transformation.transform_ibis(ibis_table)

        transformed_table = transformed_table.drop(*columns_to_cleanup)

        rename_columns: dict[str, str] = {}
        for feature in self.features:
            short_name = feature.name
            long_name = self._get_projected_feature_name(feature.name)
            if short_name in transformed_table.columns and full_feature_names:
                rename_columns[short_name] = long_name
            elif not full_feature_names:
                rename_columns[long_name] = short_name

        for rename_from, rename_to in rename_columns.items():
            if rename_from in transformed_table.columns:
                transformed_table = transformed_table.rename(**{rename_to: rename_from})

        return transformed_table

    def transform_arrow(
        self,
        pa_table: pyarrow.Table,
        full_feature_names: bool = False,
    ) -> pyarrow.Table:
        if not isinstance(pa_table, pyarrow.Table):
            raise TypeError("transform_arrow only accepts pyarrow.Table")
        columns_to_cleanup = []
        for source_fv_projection in self.source_feature_view_projections.values():
            for feature in source_fv_projection.features:
                full_feature_ref = f"{source_fv_projection.name}__{feature.name}"
                if full_feature_ref in pa_table.column_names:
                    # Make sure the partial feature name is always present
                    pa_table = pa_table.append_column(
                        feature.name, pa_table[full_feature_ref]
                    )
                    columns_to_cleanup.append(feature.name)
                elif feature.name in pa_table.column_names:
                    # Make sure the full feature name is always present
                    pa_table = pa_table.append_column(
                        full_feature_ref, pa_table[feature.name]
                    )
                    columns_to_cleanup.append(full_feature_ref)

        df_with_transformed_features: pyarrow.Table = (
            self.feature_transformation.transform_arrow(pa_table, self.features)
        )

        # Work out whether the correct columns names are used.
        rename_columns: dict[str, str] = {}
        for feature in self.features:
            short_name = feature.name
            long_name = self._get_projected_feature_name(feature.name)
            if (
                short_name in df_with_transformed_features.column_names
                and full_feature_names
            ):
                rename_columns[short_name] = long_name
            elif not full_feature_names:
                rename_columns[long_name] = short_name

        # Cleanup extra columns used for transformation
        for col in columns_to_cleanup:
            if col in df_with_transformed_features.column_names:
                df_with_transformed_features = df_with_transformed_features.drop(col)
        return df_with_transformed_features.rename_columns(
            [
                rename_columns.get(c, c)
                for c in df_with_transformed_features.column_names
            ]
        )

    def transform_dict(
        self,
        feature_dict: dict[str, Any],  # type: ignore
    ) -> dict[str, Any]:
        # we need a mapping from full feature name to short and back to do a renaming
        # The simplest thing to do is to make the full reference, copy the columns with the short reference
        # and rerun
        columns_to_cleanup: list[str] = []
        for source_fv_projection in self.source_feature_view_projections.values():
            for feature in source_fv_projection.features:
                full_feature_ref = f"{source_fv_projection.name}__{feature.name}"
                if full_feature_ref in feature_dict.keys():
                    # Make sure the partial feature name is always present
                    feature_dict[feature.name] = feature_dict[full_feature_ref]
                    columns_to_cleanup.append(str(feature.name))
                elif feature.name in feature_dict.keys():
                    # Make sure the full feature name is always present
                    feature_dict[full_feature_ref] = feature_dict[feature.name]
                    columns_to_cleanup.append(str(full_feature_ref))

        if self.singleton and self.mode == "python":
            output_dict: dict[str, Any] = (
                self.feature_transformation.transform_singleton(feature_dict)
            )
        else:
            output_dict = self.feature_transformation.transform(feature_dict)
        for feature_name in columns_to_cleanup:
            del output_dict[feature_name]
        return output_dict

    def infer_features(self) -> None:
        random_input = self._construct_random_input(singleton=self.singleton)
        inferred_features = self.feature_transformation.infer_features(random_input)

        if self.features:
            missing_features = []
            for specified_feature in self.features:
                if specified_feature not in inferred_features:
                    missing_features.append(specified_feature)
            if missing_features:
                raise SpecifiedFeaturesNotPresentError(
                    missing_features, inferred_features, self.name
                )
        else:
            self.features = inferred_features

        if not self.features:
            raise RegistryInferenceFailure(
                "OnDemandFeatureView",
                f"Could not infer Features for the feature view '{self.name}'.",
            )

    def _construct_random_input(
        self, singleton: bool = False
    ) -> dict[str, Union[list[Any], Any]]:
        rand_dict_value: dict[ValueType, Union[list[Any], Any]] = {
            ValueType.BYTES: [str.encode("hello world")],
            ValueType.STRING: ["hello world"],
            ValueType.INT32: [1],
            ValueType.INT64: [1],
            ValueType.DOUBLE: [1.0],
            ValueType.FLOAT: [1.0],
            ValueType.BOOL: [True],
            ValueType.UNIX_TIMESTAMP: [_utc_now()],
            ValueType.BYTES_LIST: [[str.encode("hello world")]],
            ValueType.STRING_LIST: [["hello world"]],
            ValueType.INT32_LIST: [[1]],
            ValueType.INT64_LIST: [[1]],
            ValueType.DOUBLE_LIST: [[1.0]],
            ValueType.FLOAT_LIST: [[1.0]],
            ValueType.BOOL_LIST: [[True]],
            ValueType.UNIX_TIMESTAMP_LIST: [[_utc_now()]],
        }
        if singleton:
            rand_dict_value = {k: rand_dict_value[k][0] for k in rand_dict_value}

        rand_missing_value = [None] if singleton else None
        feature_dict = {}
        for feature_view_projection in self.source_feature_view_projections.values():
            for feature in feature_view_projection.features:
                feature_dict[f"{feature_view_projection.name}__{feature.name}"] = (
                    rand_dict_value.get(
                        feature.dtype.to_value_type(), rand_missing_value
                    )
                )
                feature_dict[f"{feature.name}"] = rand_dict_value.get(
                    feature.dtype.to_value_type(), rand_missing_value
                )
        for request_data in self.source_request_sources.values():
            for field in request_data.schema:
                feature_dict[f"{field.name}"] = rand_dict_value.get(
                    field.dtype.to_value_type(), rand_missing_value
                )

        return feature_dict

    @staticmethod
    def get_requested_odfvs(
        feature_refs, project, registry
    ) -> list["OnDemandFeatureView"]:
        all_on_demand_feature_views = registry.list_on_demand_feature_views(
            project, allow_cache=True
        )
        requested_on_demand_feature_views: list[OnDemandFeatureView] = []
        for odfv in all_on_demand_feature_views:
            for feature in odfv.features:
                if f"{odfv.name}:{feature.name}" in feature_refs:
                    requested_on_demand_feature_views.append(odfv)
                    break
        return requested_on_demand_feature_views


def on_demand_feature_view(
    *,
    entities: Optional[List[Entity]] = None,
    schema: list[Field],
    sources: list[
        Union[
            FeatureView,
            RequestSource,
            FeatureViewProjection,
        ]
    ],
    mode: str = "pandas",
    description: str = "",
    tags: Optional[dict[str, str]] = None,
    owner: str = "",
    write_to_online_store: bool = False,
    singleton: bool = False,
):
    """
    Creates an OnDemandFeatureView object with the given user function as udf.

    Args:
        entities (Optional): The list of names of entities that this feature view is associated with.
        schema: The list of features in the output of the on demand feature view, after
            the transformation has been applied.
        sources: A map from input source names to the actual input sources, which may be
            feature views, or request data sources. These sources serve as inputs to the udf,
            which will refer to them by name.
        mode: The mode of execution (e.g,. Pandas or Python Native)
        description (optional): A human-readable description.
        tags (optional): A dictionary of key-value pairs to store arbitrary metadata.
        owner (optional): The owner of the on demand feature view, typically the email
            of the primary maintainer.
        write_to_online_store (optional): A boolean that indicates whether to write the on demand feature view to
            the online store for faster retrieval.
        singleton (optional): A boolean that indicates whether the transformation is executed on a singleton
            (only applicable when mode="python").
    """

    def mainify(obj) -> None:
        # Needed to allow dill to properly serialize the udf. Otherwise, clients will need to have a file with the same
        # name as the original file defining the ODFV.
        if obj.__module__ != "__main__":
            obj.__module__ = "__main__"

    def decorator(user_function):
        return_annotation = get_type_hints(user_function).get("return", inspect._empty)
        udf_string = dill.source.getsource(user_function)
        mainify(user_function)
        if mode == "pandas":
            if return_annotation not in (inspect._empty, pd.DataFrame):
                raise TypeError(
                    f"return signature for {user_function} is {return_annotation} but should be pd.DataFrame"
                )
            transformation = PandasTransformation(user_function, udf_string)
        elif mode == "python":
            if return_annotation not in (inspect._empty, dict[str, Any]):
                raise TypeError(
                    f"return signature for {user_function} is {return_annotation} but should be dict[str, Any]"
                )
            transformation = PythonTransformation(user_function, udf_string)
        elif mode == "substrait":
            from ibis.expr.types.relations import Table

            if return_annotation not in (inspect._empty, Table):
                raise TypeError(
                    f"return signature for {user_function} is {return_annotation} but should be ibis.expr.types.relations.Table"
                )
            transformation = SubstraitTransformation.from_ibis(user_function, sources)

        on_demand_feature_view_obj = OnDemandFeatureView(
            name=user_function.__name__,
            sources=sources,
            schema=schema,
            feature_transformation=transformation,
            mode=mode,
            description=description,
            tags=tags,
            owner=owner,
            write_to_online_store=write_to_online_store,
            entities=entities,
            singleton=singleton,
        )
        functools.update_wrapper(
            wrapper=on_demand_feature_view_obj, wrapped=user_function
        )
        return on_demand_feature_view_obj

    return decorator


def _empty_odfv_udf_fn(x: Any) -> Any:
    # just an identity mapping, otherwise we risk tripping some downstream tests
    return x
