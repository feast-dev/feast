// Code generated by protoc-gen-go. DO NOT EDIT.
// source: feast/core/Store.proto

package core

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Store_StoreType int32

const (
	Store_INVALID Store_StoreType = 0
	// Redis stores a FeatureRow element as a key, value pair.
	//
	// The Redis data types used (https://redis.io/topics/data-types):
	// - key: STRING
	// - value: STRING
	//
	// Encodings:
	// - key: byte array of RedisKey (refer to feast.storage.RedisKey)
	// - value: byte array of FeatureRow (refer to feast.types.FeatureRow)
	//
	Store_REDIS Store_StoreType = 1
	// BigQuery stores a FeatureRow element as a row in a BigQuery table.
	//
	// Table name is derived from the feature set name and version as:
	// [feature_set_name]_v[feature_set_version]
	//
	// For example:
	// A feature row for feature set "driver" and version "1" will be written
	// to table "driver_v1".
	//
	// The entities and features in a FeatureSetSpec corresponds to the
	// fields in the BigQuery table (these make up the BigQuery schema).
	// The name of the entity spec and feature spec corresponds to the column
	// names, and the value_type of entity spec and feature spec corresponds
	// to BigQuery standard SQL data type of the column.
	//
	// The following BigQuery fields are reserved for Feast internal use.
	// Ingestion of entity or feature spec with names identical
	// to the following field names will raise an exception during ingestion.
	//
	//   column_name       | column_data_type | description
	// ====================|==================|================================
	// - event_timestamp   | TIMESTAMP        | event time of the FeatureRow
	// - created_timestamp | TIMESTAMP        | processing time of the ingestion of the FeatureRow
	// - job_id            | STRING           | identifier for the job that writes the FeatureRow to the corresponding BigQuery table
	//
	// BigQuery table created will be partitioned by the field "event_timestamp"
	// of the FeatureRow (https://cloud.google.com/bigquery/docs/partitioned-tables).
	//
	// Since newer version of feature set can introduce breaking, non backward-
	// compatible BigQuery schema updates, incrementing the version of a
	// feature set will result in the creation of a new empty BigQuery table
	// with the new schema.
	//
	// The following table shows how ValueType in Feast is mapped to
	// BigQuery Standard SQL data types
	// (https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types):
	//
	// BYTES       : BYTES
	// STRING      : STRING
	// INT32       : INT64
	// INT64       : IN64
	// DOUBLE      : FLOAT64
	// FLOAT       : FLOAT64
	// BOOL        : BOOL
	// BYTES_LIST  : ARRAY
	// STRING_LIST : ARRAY
	// INT32_LIST  : ARRAY
	// INT64_LIST  : ARRAY
	// DOUBLE_LIST : ARRAY
	// FLOAT_LIST  : ARRAY
	// BOOL_LIST   : ARRAY
	//
	// The column mode in BigQuery is set to "Nullable" such that unset Value
	// in a FeatureRow corresponds to NULL value in BigQuery.
	//
	Store_BIGQUERY Store_StoreType = 2
	// Unsupported in Feast 0.3
	Store_CASSANDRA Store_StoreType = 3
)

var Store_StoreType_name = map[int32]string{
	0: "INVALID",
	1: "REDIS",
	2: "BIGQUERY",
	3: "CASSANDRA",
}

var Store_StoreType_value = map[string]int32{
	"INVALID":   0,
	"REDIS":     1,
	"BIGQUERY":  2,
	"CASSANDRA": 3,
}

func (x Store_StoreType) String() string {
	return proto.EnumName(Store_StoreType_name, int32(x))
}

func (Store_StoreType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4b177bc9ccf64875, []int{0, 0}
}

// Store provides a location where Feast reads and writes feature values.
// Feature values will be written to the Store in the form of FeatureRow elements.
// The way FeatureRow is encoded and decoded when it is written to and read from
// the Store depends on the type of the Store.
//
// For example, a FeatureRow will materialize as a row in a table in
// BigQuery but it will materialize as a key, value pair element in Redis.
//
type Store struct {
	// Name of the store.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Type of store.
	Type Store_StoreType `protobuf:"varint,2,opt,name=type,proto3,enum=feast.core.Store_StoreType" json:"type,omitempty"`
	// Feature sets to subscribe to.
	Subscriptions []*Store_Subscription `protobuf:"bytes,4,rep,name=subscriptions,proto3" json:"subscriptions,omitempty"`
	// Configuration to connect to the store. Required.
	//
	// Types that are valid to be assigned to Config:
	//	*Store_RedisConfig_
	//	*Store_BigqueryConfig
	//	*Store_CassandraConfig_
	Config               isStore_Config `protobuf_oneof:"config"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Store) Reset()         { *m = Store{} }
func (m *Store) String() string { return proto.CompactTextString(m) }
func (*Store) ProtoMessage()    {}
func (*Store) Descriptor() ([]byte, []int) {
	return fileDescriptor_4b177bc9ccf64875, []int{0}
}

func (m *Store) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Store.Unmarshal(m, b)
}
func (m *Store) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Store.Marshal(b, m, deterministic)
}
func (m *Store) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Store.Merge(m, src)
}
func (m *Store) XXX_Size() int {
	return xxx_messageInfo_Store.Size(m)
}
func (m *Store) XXX_DiscardUnknown() {
	xxx_messageInfo_Store.DiscardUnknown(m)
}

var xxx_messageInfo_Store proto.InternalMessageInfo

func (m *Store) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Store) GetType() Store_StoreType {
	if m != nil {
		return m.Type
	}
	return Store_INVALID
}

func (m *Store) GetSubscriptions() []*Store_Subscription {
	if m != nil {
		return m.Subscriptions
	}
	return nil
}

type isStore_Config interface {
	isStore_Config()
}

type Store_RedisConfig_ struct {
	RedisConfig *Store_RedisConfig `protobuf:"bytes,11,opt,name=redis_config,json=redisConfig,proto3,oneof"`
}

type Store_BigqueryConfig struct {
	BigqueryConfig *Store_BigQueryConfig `protobuf:"bytes,12,opt,name=bigquery_config,json=bigqueryConfig,proto3,oneof"`
}

type Store_CassandraConfig_ struct {
	CassandraConfig *Store_CassandraConfig `protobuf:"bytes,13,opt,name=cassandra_config,json=cassandraConfig,proto3,oneof"`
}

func (*Store_RedisConfig_) isStore_Config() {}

func (*Store_BigqueryConfig) isStore_Config() {}

func (*Store_CassandraConfig_) isStore_Config() {}

func (m *Store) GetConfig() isStore_Config {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *Store) GetRedisConfig() *Store_RedisConfig {
	if x, ok := m.GetConfig().(*Store_RedisConfig_); ok {
		return x.RedisConfig
	}
	return nil
}

func (m *Store) GetBigqueryConfig() *Store_BigQueryConfig {
	if x, ok := m.GetConfig().(*Store_BigqueryConfig); ok {
		return x.BigqueryConfig
	}
	return nil
}

func (m *Store) GetCassandraConfig() *Store_CassandraConfig {
	if x, ok := m.GetConfig().(*Store_CassandraConfig_); ok {
		return x.CassandraConfig
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Store) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Store_RedisConfig_)(nil),
		(*Store_BigqueryConfig)(nil),
		(*Store_CassandraConfig_)(nil),
	}
}

type Store_RedisConfig struct {
	Host                 string   `protobuf:"bytes,1,opt,name=host,proto3" json:"host,omitempty"`
	Port                 int32    `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Store_RedisConfig) Reset()         { *m = Store_RedisConfig{} }
func (m *Store_RedisConfig) String() string { return proto.CompactTextString(m) }
func (*Store_RedisConfig) ProtoMessage()    {}
func (*Store_RedisConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_4b177bc9ccf64875, []int{0, 0}
}

func (m *Store_RedisConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Store_RedisConfig.Unmarshal(m, b)
}
func (m *Store_RedisConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Store_RedisConfig.Marshal(b, m, deterministic)
}
func (m *Store_RedisConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Store_RedisConfig.Merge(m, src)
}
func (m *Store_RedisConfig) XXX_Size() int {
	return xxx_messageInfo_Store_RedisConfig.Size(m)
}
func (m *Store_RedisConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_Store_RedisConfig.DiscardUnknown(m)
}

var xxx_messageInfo_Store_RedisConfig proto.InternalMessageInfo

func (m *Store_RedisConfig) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *Store_RedisConfig) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

type Store_BigQueryConfig struct {
	ProjectId            string   `protobuf:"bytes,1,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	DatasetId            string   `protobuf:"bytes,2,opt,name=dataset_id,json=datasetId,proto3" json:"dataset_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Store_BigQueryConfig) Reset()         { *m = Store_BigQueryConfig{} }
func (m *Store_BigQueryConfig) String() string { return proto.CompactTextString(m) }
func (*Store_BigQueryConfig) ProtoMessage()    {}
func (*Store_BigQueryConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_4b177bc9ccf64875, []int{0, 1}
}

func (m *Store_BigQueryConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Store_BigQueryConfig.Unmarshal(m, b)
}
func (m *Store_BigQueryConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Store_BigQueryConfig.Marshal(b, m, deterministic)
}
func (m *Store_BigQueryConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Store_BigQueryConfig.Merge(m, src)
}
func (m *Store_BigQueryConfig) XXX_Size() int {
	return xxx_messageInfo_Store_BigQueryConfig.Size(m)
}
func (m *Store_BigQueryConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_Store_BigQueryConfig.DiscardUnknown(m)
}

var xxx_messageInfo_Store_BigQueryConfig proto.InternalMessageInfo

func (m *Store_BigQueryConfig) GetProjectId() string {
	if m != nil {
		return m.ProjectId
	}
	return ""
}

func (m *Store_BigQueryConfig) GetDatasetId() string {
	if m != nil {
		return m.DatasetId
	}
	return ""
}

type Store_CassandraConfig struct {
	Host                 string   `protobuf:"bytes,1,opt,name=host,proto3" json:"host,omitempty"`
	Port                 int32    `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Store_CassandraConfig) Reset()         { *m = Store_CassandraConfig{} }
func (m *Store_CassandraConfig) String() string { return proto.CompactTextString(m) }
func (*Store_CassandraConfig) ProtoMessage()    {}
func (*Store_CassandraConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_4b177bc9ccf64875, []int{0, 2}
}

func (m *Store_CassandraConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Store_CassandraConfig.Unmarshal(m, b)
}
func (m *Store_CassandraConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Store_CassandraConfig.Marshal(b, m, deterministic)
}
func (m *Store_CassandraConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Store_CassandraConfig.Merge(m, src)
}
func (m *Store_CassandraConfig) XXX_Size() int {
	return xxx_messageInfo_Store_CassandraConfig.Size(m)
}
func (m *Store_CassandraConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_Store_CassandraConfig.DiscardUnknown(m)
}

var xxx_messageInfo_Store_CassandraConfig proto.InternalMessageInfo

func (m *Store_CassandraConfig) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *Store_CassandraConfig) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

type Store_Subscription struct {
	// Name of project that the feature sets belongs to. This can be one of
	// - [project_name]
	// - *
	// If an asterisk is provided, filtering on projects will be disabled. All projects will
	// be matched. It is NOT possible to provide an asterisk with a string in order to do
	// pattern matching.
	Project string `protobuf:"bytes,3,opt,name=project,proto3" json:"project,omitempty"`
	// Name of the desired feature set. Asterisks can be used as wildcards in the name.
	// Matching on names is only permitted if a specific project is defined. It is disallowed
	// If the project name is set to "*"
	// e.g.
	// - * can be used to match all feature sets
	// - my-feature-set* can be used to match all features prefixed by "my-feature-set"
	// - my-feature-set-6 can be used to select a single feature set
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Versions of the given feature sets that will be returned.
	// Valid options for version:
	//     "latest": only the latest version is returned.
	//     "*": Subscribe to all versions
	//     [version number]: pin to a specific version. Project and feature set name must be
	//                       explicitly defined if a specific version is pinned.
	Version              string   `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Store_Subscription) Reset()         { *m = Store_Subscription{} }
func (m *Store_Subscription) String() string { return proto.CompactTextString(m) }
func (*Store_Subscription) ProtoMessage()    {}
func (*Store_Subscription) Descriptor() ([]byte, []int) {
	return fileDescriptor_4b177bc9ccf64875, []int{0, 3}
}

func (m *Store_Subscription) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Store_Subscription.Unmarshal(m, b)
}
func (m *Store_Subscription) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Store_Subscription.Marshal(b, m, deterministic)
}
func (m *Store_Subscription) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Store_Subscription.Merge(m, src)
}
func (m *Store_Subscription) XXX_Size() int {
	return xxx_messageInfo_Store_Subscription.Size(m)
}
func (m *Store_Subscription) XXX_DiscardUnknown() {
	xxx_messageInfo_Store_Subscription.DiscardUnknown(m)
}

var xxx_messageInfo_Store_Subscription proto.InternalMessageInfo

func (m *Store_Subscription) GetProject() string {
	if m != nil {
		return m.Project
	}
	return ""
}

func (m *Store_Subscription) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Store_Subscription) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func init() {
	proto.RegisterEnum("feast.core.Store_StoreType", Store_StoreType_name, Store_StoreType_value)
	proto.RegisterType((*Store)(nil), "feast.core.Store")
	proto.RegisterType((*Store_RedisConfig)(nil), "feast.core.Store.RedisConfig")
	proto.RegisterType((*Store_BigQueryConfig)(nil), "feast.core.Store.BigQueryConfig")
	proto.RegisterType((*Store_CassandraConfig)(nil), "feast.core.Store.CassandraConfig")
	proto.RegisterType((*Store_Subscription)(nil), "feast.core.Store.Subscription")
}

func init() { proto.RegisterFile("feast/core/Store.proto", fileDescriptor_4b177bc9ccf64875) }

var fileDescriptor_4b177bc9ccf64875 = []byte{
	// 450 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x93, 0x4f, 0x6f, 0xd3, 0x30,
	0x18, 0xc6, 0x97, 0xfe, 0x59, 0x97, 0x37, 0xfd, 0x13, 0xf9, 0x80, 0xa2, 0xa2, 0xa1, 0xb0, 0x53,
	0x4f, 0xb1, 0x54, 0xc4, 0x81, 0x1b, 0x4d, 0x3b, 0x41, 0x04, 0xaa, 0x98, 0x0b, 0x93, 0xe0, 0x32,
	0xa5, 0x89, 0x97, 0x79, 0xd3, 0xe2, 0x60, 0xbb, 0x48, 0xfd, 0xa8, 0x7c, 0x1b, 0x64, 0x27, 0x69,
	0x53, 0xda, 0xc3, 0x2e, 0x91, 0xfd, 0xbc, 0xcf, 0xf3, 0xcb, 0x2b, 0xdb, 0x2f, 0xbc, 0xba, 0xa7,
	0xb1, 0x54, 0x38, 0xe1, 0x82, 0xe2, 0x95, 0xe2, 0x82, 0x06, 0x85, 0xe0, 0x8a, 0x23, 0x30, 0x7a,
	0xa0, 0xf5, 0xab, 0xbf, 0x5d, 0xe8, 0x9a, 0x1a, 0x42, 0xd0, 0xc9, 0xe3, 0x67, 0xea, 0x59, 0xbe,
	0x35, 0xb1, 0x89, 0x59, 0x23, 0x0c, 0x1d, 0xb5, 0x2d, 0xa8, 0xd7, 0xf2, 0xad, 0xc9, 0x70, 0xfa,
	0x3a, 0xd8, 0x07, 0x83, 0x12, 0x68, 0xbe, 0xdf, 0xb7, 0x05, 0x25, 0xc6, 0x88, 0x16, 0x30, 0x90,
	0x9b, 0xb5, 0x4c, 0x04, 0x2b, 0x14, 0xe3, 0xb9, 0xf4, 0x3a, 0x7e, 0x7b, 0xe2, 0x4c, 0xdf, 0x9c,
	0x48, 0x36, 0x6c, 0xe4, 0x30, 0x84, 0x42, 0xe8, 0x0b, 0x9a, 0x32, 0x79, 0x97, 0xf0, 0xfc, 0x9e,
	0x65, 0x9e, 0xe3, 0x5b, 0x13, 0x67, 0x7a, 0x79, 0x0c, 0x21, 0xda, 0x35, 0x37, 0xa6, 0xcf, 0x67,
	0xc4, 0x11, 0xfb, 0x2d, 0xfa, 0x02, 0xa3, 0x35, 0xcb, 0x7e, 0x6f, 0xa8, 0xd8, 0xd6, 0x98, 0xbe,
	0xc1, 0xf8, 0xc7, 0x98, 0x90, 0x65, 0x37, 0xda, 0xb8, 0x23, 0x0d, 0xeb, 0x68, 0x05, 0x5b, 0x82,
	0x9b, 0xc4, 0x52, 0xc6, 0x79, 0x2a, 0xe2, 0x9a, 0x36, 0x30, 0xb4, 0xb7, 0xc7, 0xb4, 0x79, 0xed,
	0xdc, 0xe1, 0x46, 0xc9, 0xa1, 0x34, 0x7e, 0x0f, 0x4e, 0xa3, 0x75, 0x7d, 0xf4, 0x0f, 0x5c, 0xaa,
	0xfa, 0xe8, 0xf5, 0x5a, 0x6b, 0x05, 0x17, 0xca, 0x1c, 0x7d, 0x97, 0x98, 0xf5, 0x78, 0x09, 0xc3,
	0xc3, 0x56, 0xd1, 0x25, 0x40, 0x21, 0xf8, 0x23, 0x4d, 0xd4, 0x1d, 0x4b, 0xab, 0xbc, 0x5d, 0x29,
	0x51, 0xaa, 0xcb, 0x69, 0xac, 0x62, 0x49, 0x4d, 0xb9, 0x55, 0x96, 0x2b, 0x25, 0x4a, 0xc7, 0x1f,
	0x60, 0xf4, 0x5f, 0xb3, 0x2f, 0x6e, 0xe5, 0x16, 0xfa, 0xcd, 0x1b, 0x44, 0x1e, 0xf4, 0xaa, 0xdf,
	0x7a, 0x6d, 0x13, 0xad, 0xb7, 0x27, 0xdf, 0x95, 0x07, 0xbd, 0x3f, 0x54, 0x48, 0xc6, 0xf3, 0xaa,
	0xa9, 0x7a, 0x7b, 0xf5, 0x11, 0xec, 0xdd, 0x9b, 0x42, 0x0e, 0xf4, 0xa2, 0xe5, 0xed, 0xec, 0x6b,
	0xb4, 0x70, 0xcf, 0x90, 0x0d, 0x5d, 0x72, 0xbd, 0x88, 0x56, 0xae, 0x85, 0xfa, 0x70, 0x11, 0x46,
	0x9f, 0x6e, 0x7e, 0x5c, 0x93, 0x9f, 0x6e, 0x0b, 0x0d, 0xc0, 0x9e, 0xcf, 0x56, 0xab, 0xd9, 0x72,
	0x41, 0x66, 0x6e, 0x3b, 0xbc, 0x80, 0xf3, 0xf2, 0x86, 0xc2, 0x08, 0x1a, 0x2f, 0x3d, 0x04, 0xc3,
	0xfd, 0xa6, 0x27, 0xe0, 0x17, 0xce, 0x98, 0x7a, 0xd8, 0xac, 0x83, 0x84, 0x3f, 0xe3, 0x8c, 0x3f,
	0xd2, 0x27, 0x5c, 0x8e, 0x8a, 0x4c, 0x9f, 0x70, 0xc6, 0xb1, 0x19, 0x13, 0x89, 0xf7, 0xe3, 0xb3,
	0x3e, 0x37, 0xd2, 0xbb, 0x7f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x56, 0xfe, 0x58, 0x14, 0x53, 0x03,
	0x00, 0x00,
}
