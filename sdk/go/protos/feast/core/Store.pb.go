// Code generated by protoc-gen-go. DO NOT EDIT.
// source: feast/core/Store.proto

package core

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	duration "github.com/golang/protobuf/ptypes/duration"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Store_StoreType int32

const (
	Store_INVALID Store_StoreType = 0
	// Redis stores a FeatureRow element as a key, value pair.
	//
	// The Redis data types used (https://redis.io/topics/data-types):
	// - key: STRING
	// - value: STRING
	//
	// Encodings:
	// - key: byte array of RedisKey (refer to feast.storage.RedisKey)
	// - value: byte array of FeatureRow (refer to feast.types.FeatureRow)
	//
	Store_REDIS Store_StoreType = 1
	// BigQuery stores a FeatureRow element as a row in a BigQuery table.
	//
	// Table name is derived from the feature set name and version as:
	// [feature_set_name]_v[feature_set_version]
	//
	// For example:
	// A feature row for feature set "driver" and version "1" will be written
	// to table "driver_v1".
	//
	// The entities and features in a FeatureSetSpec corresponds to the
	// fields in the BigQuery table (these make up the BigQuery schema).
	// The name of the entity spec and feature spec corresponds to the column
	// names, and the value_type of entity spec and feature spec corresponds
	// to BigQuery standard SQL data type of the column.
	//
	// The following BigQuery fields are reserved for Feast internal use.
	// Ingestion of entity or feature spec with names identical
	// to the following field names will raise an exception during ingestion.
	//
	//   column_name       | column_data_type | description
	// ====================|==================|================================
	// - event_timestamp   | TIMESTAMP        | event time of the FeatureRow
	// - created_timestamp | TIMESTAMP        | processing time of the ingestion of the FeatureRow
	// - job_id            | STRING           | identifier for the job that writes the FeatureRow to the corresponding BigQuery table
	//
	// BigQuery table created will be partitioned by the field "event_timestamp"
	// of the FeatureRow (https://cloud.google.com/bigquery/docs/partitioned-tables).
	//
	// Since newer version of feature set can introduce breaking, non backward-
	// compatible BigQuery schema updates, incrementing the version of a
	// feature set will result in the creation of a new empty BigQuery table
	// with the new schema.
	//
	// The following table shows how ValueType in Feast is mapped to
	// BigQuery Standard SQL data types
	// (https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types):
	//
	// BYTES       : BYTES
	// STRING      : STRING
	// INT32       : INT64
	// INT64       : IN64
	// DOUBLE      : FLOAT64
	// FLOAT       : FLOAT64
	// BOOL        : BOOL
	// BYTES_LIST  : ARRAY
	// STRING_LIST : ARRAY
	// INT32_LIST  : ARRAY
	// INT64_LIST  : ARRAY
	// DOUBLE_LIST : ARRAY
	// FLOAT_LIST  : ARRAY
	// BOOL_LIST   : ARRAY
	//
	// The column mode in BigQuery is set to "Nullable" such that unset Value
	// in a FeatureRow corresponds to NULL value in BigQuery.
	//
	Store_BIGQUERY Store_StoreType = 2
	// Cassandra stores entities as a string partition key, feature as clustering column.
	// NOTE: This store currently uses max_age defined in FeatureSet for ttl
	//
	// Columns:
	// - entities: concatenated string of feature set name and all entities' keys and values
	//   entities concatenated format - [feature_set]:[entity_name1=entity_value1]|[entity_name2=entity_value2]
	//   TODO: string representation of float or double types may have different value in different runtime or platform
	// - feature: clustering column where each feature is a column
	// - value: byte array of Value (refer to feast.types.Value)
	//
	// Internal columns:
	// - writeTime: timestamp of the written record. This is used to ensure that new records are not replaced
	//              by older ones
	// - ttl: expiration time the record. Currently using max_age from feature set spec as ttl
	Store_CASSANDRA Store_StoreType = 3
)

var Store_StoreType_name = map[int32]string{
	0: "INVALID",
	1: "REDIS",
	2: "BIGQUERY",
	3: "CASSANDRA",
}

var Store_StoreType_value = map[string]int32{
	"INVALID":   0,
	"REDIS":     1,
	"BIGQUERY":  2,
	"CASSANDRA": 3,
}

func (x Store_StoreType) String() string {
	return proto.EnumName(Store_StoreType_name, int32(x))
}

func (Store_StoreType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4b177bc9ccf64875, []int{0, 0}
}

// Store provides a location where Feast reads and writes feature values.
// Feature values will be written to the Store in the form of FeatureRow elements.
// The way FeatureRow is encoded and decoded when it is written to and read from
// the Store depends on the type of the Store.
//
// For example, a FeatureRow will materialize as a row in a table in
// BigQuery but it will materialize as a key, value pair element in Redis.
//
type Store struct {
	// Name of the store.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Type of store.
	Type Store_StoreType `protobuf:"varint,2,opt,name=type,proto3,enum=feast.core.Store_StoreType" json:"type,omitempty"`
	// Feature sets to subscribe to.
	Subscriptions []*Store_Subscription `protobuf:"bytes,4,rep,name=subscriptions,proto3" json:"subscriptions,omitempty"`
	// Configuration to connect to the store. Required.
	//
	// Types that are valid to be assigned to Config:
	//	*Store_RedisConfig_
	//	*Store_BigqueryConfig
	//	*Store_CassandraConfig_
	Config               isStore_Config `protobuf_oneof:"config"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Store) Reset()         { *m = Store{} }
func (m *Store) String() string { return proto.CompactTextString(m) }
func (*Store) ProtoMessage()    {}
func (*Store) Descriptor() ([]byte, []int) {
	return fileDescriptor_4b177bc9ccf64875, []int{0}
}

func (m *Store) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Store.Unmarshal(m, b)
}
func (m *Store) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Store.Marshal(b, m, deterministic)
}
func (m *Store) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Store.Merge(m, src)
}
func (m *Store) XXX_Size() int {
	return xxx_messageInfo_Store.Size(m)
}
func (m *Store) XXX_DiscardUnknown() {
	xxx_messageInfo_Store.DiscardUnknown(m)
}

var xxx_messageInfo_Store proto.InternalMessageInfo

func (m *Store) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Store) GetType() Store_StoreType {
	if m != nil {
		return m.Type
	}
	return Store_INVALID
}

func (m *Store) GetSubscriptions() []*Store_Subscription {
	if m != nil {
		return m.Subscriptions
	}
	return nil
}

type isStore_Config interface {
	isStore_Config()
}

type Store_RedisConfig_ struct {
	RedisConfig *Store_RedisConfig `protobuf:"bytes,11,opt,name=redis_config,json=redisConfig,proto3,oneof"`
}

type Store_BigqueryConfig struct {
	BigqueryConfig *Store_BigQueryConfig `protobuf:"bytes,12,opt,name=bigquery_config,json=bigqueryConfig,proto3,oneof"`
}

type Store_CassandraConfig_ struct {
	CassandraConfig *Store_CassandraConfig `protobuf:"bytes,13,opt,name=cassandra_config,json=cassandraConfig,proto3,oneof"`
}

func (*Store_RedisConfig_) isStore_Config() {}

func (*Store_BigqueryConfig) isStore_Config() {}

func (*Store_CassandraConfig_) isStore_Config() {}

func (m *Store) GetConfig() isStore_Config {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *Store) GetRedisConfig() *Store_RedisConfig {
	if x, ok := m.GetConfig().(*Store_RedisConfig_); ok {
		return x.RedisConfig
	}
	return nil
}

func (m *Store) GetBigqueryConfig() *Store_BigQueryConfig {
	if x, ok := m.GetConfig().(*Store_BigqueryConfig); ok {
		return x.BigqueryConfig
	}
	return nil
}

func (m *Store) GetCassandraConfig() *Store_CassandraConfig {
	if x, ok := m.GetConfig().(*Store_CassandraConfig_); ok {
		return x.CassandraConfig
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Store) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Store_RedisConfig_)(nil),
		(*Store_BigqueryConfig)(nil),
		(*Store_CassandraConfig_)(nil),
	}
}

type Store_RedisConfig struct {
	Host string `protobuf:"bytes,1,opt,name=host,proto3" json:"host,omitempty"`
	Port int32  `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
	// Optional. The number of milliseconds to wait before retrying failed Redis connection.
	// By default, Feast uses exponential backoff policy and "initial_backoff_ms" sets the initial wait duration.
	InitialBackoffMs int32 `protobuf:"varint,3,opt,name=initial_backoff_ms,json=initialBackoffMs,proto3" json:"initial_backoff_ms,omitempty"`
	// Optional. Maximum total number of retries for connecting to Redis. Default to zero retries.
	MaxRetries           int32    `protobuf:"varint,4,opt,name=max_retries,json=maxRetries,proto3" json:"max_retries,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Store_RedisConfig) Reset()         { *m = Store_RedisConfig{} }
func (m *Store_RedisConfig) String() string { return proto.CompactTextString(m) }
func (*Store_RedisConfig) ProtoMessage()    {}
func (*Store_RedisConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_4b177bc9ccf64875, []int{0, 0}
}

func (m *Store_RedisConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Store_RedisConfig.Unmarshal(m, b)
}
func (m *Store_RedisConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Store_RedisConfig.Marshal(b, m, deterministic)
}
func (m *Store_RedisConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Store_RedisConfig.Merge(m, src)
}
func (m *Store_RedisConfig) XXX_Size() int {
	return xxx_messageInfo_Store_RedisConfig.Size(m)
}
func (m *Store_RedisConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_Store_RedisConfig.DiscardUnknown(m)
}

var xxx_messageInfo_Store_RedisConfig proto.InternalMessageInfo

func (m *Store_RedisConfig) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *Store_RedisConfig) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *Store_RedisConfig) GetInitialBackoffMs() int32 {
	if m != nil {
		return m.InitialBackoffMs
	}
	return 0
}

func (m *Store_RedisConfig) GetMaxRetries() int32 {
	if m != nil {
		return m.MaxRetries
	}
	return 0
}

type Store_BigQueryConfig struct {
	ProjectId            string   `protobuf:"bytes,1,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	DatasetId            string   `protobuf:"bytes,2,opt,name=dataset_id,json=datasetId,proto3" json:"dataset_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Store_BigQueryConfig) Reset()         { *m = Store_BigQueryConfig{} }
func (m *Store_BigQueryConfig) String() string { return proto.CompactTextString(m) }
func (*Store_BigQueryConfig) ProtoMessage()    {}
func (*Store_BigQueryConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_4b177bc9ccf64875, []int{0, 1}
}

func (m *Store_BigQueryConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Store_BigQueryConfig.Unmarshal(m, b)
}
func (m *Store_BigQueryConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Store_BigQueryConfig.Marshal(b, m, deterministic)
}
func (m *Store_BigQueryConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Store_BigQueryConfig.Merge(m, src)
}
func (m *Store_BigQueryConfig) XXX_Size() int {
	return xxx_messageInfo_Store_BigQueryConfig.Size(m)
}
func (m *Store_BigQueryConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_Store_BigQueryConfig.DiscardUnknown(m)
}

var xxx_messageInfo_Store_BigQueryConfig proto.InternalMessageInfo

func (m *Store_BigQueryConfig) GetProjectId() string {
	if m != nil {
		return m.ProjectId
	}
	return ""
}

func (m *Store_BigQueryConfig) GetDatasetId() string {
	if m != nil {
		return m.DatasetId
	}
	return ""
}

type Store_CassandraConfig struct {
	// - bootstrapHosts: [comma delimited value of hosts]
	BootstrapHosts string `protobuf:"bytes,1,opt,name=bootstrap_hosts,json=bootstrapHosts,proto3" json:"bootstrap_hosts,omitempty"`
	Port           int32  `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
	Keyspace       string `protobuf:"bytes,3,opt,name=keyspace,proto3" json:"keyspace,omitempty"`
	// Please note that table name must be "feature_store" as is specified in the @Table annotation of the
	// datastax object mapper
	TableName string `protobuf:"bytes,4,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
	// This specifies the replication strategy to use. Please refer to docs for more details:
	// https://docs.datastax.com/en/dse/6.7/cql/cql/cql_reference/cql_commands/cqlCreateKeyspace.html#cqlCreateKeyspace__cqlCreateKeyspacereplicationmap-Pr3yUQ7t
	ReplicationOptions map[string]string `protobuf:"bytes,5,rep,name=replication_options,json=replicationOptions,proto3" json:"replication_options,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Default expiration in seconds to use when FeatureSetSpec does not have max_age defined.
	// Specify 0 for no default expiration
	DefaultTtl           *duration.Duration `protobuf:"bytes,6,opt,name=default_ttl,json=defaultTtl,proto3" json:"default_ttl,omitempty"`
	Versionless          bool               `protobuf:"varint,7,opt,name=versionless,proto3" json:"versionless,omitempty"`
	Consistency          string             `protobuf:"bytes,8,opt,name=consistency,proto3" json:"consistency,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *Store_CassandraConfig) Reset()         { *m = Store_CassandraConfig{} }
func (m *Store_CassandraConfig) String() string { return proto.CompactTextString(m) }
func (*Store_CassandraConfig) ProtoMessage()    {}
func (*Store_CassandraConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_4b177bc9ccf64875, []int{0, 2}
}

func (m *Store_CassandraConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Store_CassandraConfig.Unmarshal(m, b)
}
func (m *Store_CassandraConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Store_CassandraConfig.Marshal(b, m, deterministic)
}
func (m *Store_CassandraConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Store_CassandraConfig.Merge(m, src)
}
func (m *Store_CassandraConfig) XXX_Size() int {
	return xxx_messageInfo_Store_CassandraConfig.Size(m)
}
func (m *Store_CassandraConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_Store_CassandraConfig.DiscardUnknown(m)
}

var xxx_messageInfo_Store_CassandraConfig proto.InternalMessageInfo

func (m *Store_CassandraConfig) GetBootstrapHosts() string {
	if m != nil {
		return m.BootstrapHosts
	}
	return ""
}

func (m *Store_CassandraConfig) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *Store_CassandraConfig) GetKeyspace() string {
	if m != nil {
		return m.Keyspace
	}
	return ""
}

func (m *Store_CassandraConfig) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

func (m *Store_CassandraConfig) GetReplicationOptions() map[string]string {
	if m != nil {
		return m.ReplicationOptions
	}
	return nil
}

func (m *Store_CassandraConfig) GetDefaultTtl() *duration.Duration {
	if m != nil {
		return m.DefaultTtl
	}
	return nil
}

func (m *Store_CassandraConfig) GetVersionless() bool {
	if m != nil {
		return m.Versionless
	}
	return false
}

func (m *Store_CassandraConfig) GetConsistency() string {
	if m != nil {
		return m.Consistency
	}
	return ""
}

type Store_Subscription struct {
	// Name of project that the feature sets belongs to. This can be one of
	// - [project_name]
	// - *
	// If an asterisk is provided, filtering on projects will be disabled. All projects will
	// be matched. It is NOT possible to provide an asterisk with a string in order to do
	// pattern matching.
	Project string `protobuf:"bytes,3,opt,name=project,proto3" json:"project,omitempty"`
	// Name of the desired feature set. Asterisks can be used as wildcards in the name.
	// Matching on names is only permitted if a specific project is defined. It is disallowed
	// If the project name is set to "*"
	// e.g.
	// - * can be used to match all feature sets
	// - my-feature-set* can be used to match all features prefixed by "my-feature-set"
	// - my-feature-set-6 can be used to select a single feature set
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Versions of the given feature sets that will be returned.
	// Valid options for version:
	//     "latest": only the latest version is returned.
	//     "*": Subscribe to all versions
	//     [version number]: pin to a specific version. Project and feature set name must be
	//                       explicitly defined if a specific version is pinned.
	Version              string   `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Store_Subscription) Reset()         { *m = Store_Subscription{} }
func (m *Store_Subscription) String() string { return proto.CompactTextString(m) }
func (*Store_Subscription) ProtoMessage()    {}
func (*Store_Subscription) Descriptor() ([]byte, []int) {
	return fileDescriptor_4b177bc9ccf64875, []int{0, 3}
}

func (m *Store_Subscription) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Store_Subscription.Unmarshal(m, b)
}
func (m *Store_Subscription) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Store_Subscription.Marshal(b, m, deterministic)
}
func (m *Store_Subscription) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Store_Subscription.Merge(m, src)
}
func (m *Store_Subscription) XXX_Size() int {
	return xxx_messageInfo_Store_Subscription.Size(m)
}
func (m *Store_Subscription) XXX_DiscardUnknown() {
	xxx_messageInfo_Store_Subscription.DiscardUnknown(m)
}

var xxx_messageInfo_Store_Subscription proto.InternalMessageInfo

func (m *Store_Subscription) GetProject() string {
	if m != nil {
		return m.Project
	}
	return ""
}

func (m *Store_Subscription) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Store_Subscription) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func init() {
	proto.RegisterEnum("feast.core.Store_StoreType", Store_StoreType_name, Store_StoreType_value)
	proto.RegisterType((*Store)(nil), "feast.core.Store")
	proto.RegisterType((*Store_RedisConfig)(nil), "feast.core.Store.RedisConfig")
	proto.RegisterType((*Store_BigQueryConfig)(nil), "feast.core.Store.BigQueryConfig")
	proto.RegisterType((*Store_CassandraConfig)(nil), "feast.core.Store.CassandraConfig")
	proto.RegisterMapType((map[string]string)(nil), "feast.core.Store.CassandraConfig.ReplicationOptionsEntry")
	proto.RegisterType((*Store_Subscription)(nil), "feast.core.Store.Subscription")
}

func init() {
	proto.RegisterFile("feast/core/Store.proto", fileDescriptor_4b177bc9ccf64875)
}

var fileDescriptor_4b177bc9ccf64875 = []byte{
	// 699 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x54, 0x5f, 0x6f, 0xda, 0x48,
	0x10, 0x8f, 0xf9, 0x13, 0x60, 0x4c, 0x00, 0xed, 0x9d, 0xee, 0x7c, 0x9c, 0x92, 0xe3, 0xf2, 0x72,
	0x3c, 0x9c, 0x6c, 0x29, 0x7d, 0x69, 0xf3, 0x54, 0x08, 0xa8, 0x41, 0x6d, 0x69, 0x63, 0xd2, 0x48,
	0xed, 0x8b, 0xb5, 0xb6, 0x17, 0xc7, 0xc1, 0x78, 0xdd, 0xdd, 0x25, 0x0a, 0xef, 0xfd, 0x3a, 0xfd,
	0x06, 0xfd, 0x70, 0xd5, 0xae, 0xd7, 0x40, 0x4a, 0xaa, 0xbe, 0x58, 0xbb, 0xbf, 0xf9, 0xcd, 0xcf,
	0x33, 0xb3, 0x33, 0x03, 0x7f, 0xcc, 0x09, 0xe6, 0xc2, 0x09, 0x28, 0x23, 0xce, 0x4c, 0x50, 0x46,
	0xec, 0x8c, 0x51, 0x41, 0x11, 0x28, 0xdc, 0x96, 0x78, 0xf7, 0x24, 0xa2, 0x34, 0x4a, 0x88, 0xa3,
	0x2c, 0xfe, 0x6a, 0xee, 0x84, 0x2b, 0x86, 0x45, 0x4c, 0xd3, 0x9c, 0x7b, 0xfa, 0xb5, 0x01, 0x55,
	0xe5, 0x8b, 0x10, 0x54, 0x52, 0xbc, 0x24, 0x96, 0xd1, 0x33, 0xfa, 0x0d, 0x57, 0x9d, 0x91, 0x03,
	0x15, 0xb1, 0xce, 0x88, 0x55, 0xea, 0x19, 0xfd, 0xd6, 0xd9, 0xdf, 0xf6, 0x56, 0xd8, 0xce, 0x7f,
	0xa8, 0xbe, 0xd7, 0xeb, 0x8c, 0xb8, 0x8a, 0x88, 0x46, 0x70, 0xc4, 0x57, 0x3e, 0x0f, 0x58, 0x9c,
	0xc9, 0x9f, 0x70, 0xab, 0xd2, 0x2b, 0xf7, 0xcd, 0xb3, 0x93, 0x27, 0x3c, 0x77, 0x68, 0xee, 0x63,
	0x27, 0x34, 0x84, 0x26, 0x23, 0x61, 0xcc, 0xbd, 0x80, 0xa6, 0xf3, 0x38, 0xb2, 0xcc, 0x9e, 0xd1,
	0x37, 0xcf, 0x8e, 0xf7, 0x45, 0x5c, 0xc9, 0xba, 0x50, 0xa4, 0xcb, 0x03, 0xd7, 0x64, 0xdb, 0x2b,
	0x7a, 0x0d, 0x6d, 0x3f, 0x8e, 0x3e, 0xaf, 0x08, 0x5b, 0x17, 0x32, 0x4d, 0x25, 0xd3, 0xdb, 0x97,
	0x19, 0xc6, 0xd1, 0x95, 0x24, 0x6e, 0x94, 0x5a, 0x85, 0xab, 0x16, 0x9b, 0x42, 0x27, 0xc0, 0x9c,
	0xe3, 0x34, 0x64, 0xb8, 0x50, 0x3b, 0x52, 0x6a, 0xff, 0xee, 0xab, 0x5d, 0x14, 0xcc, 0x8d, 0x5c,
	0x3b, 0x78, 0x0c, 0x75, 0xbf, 0x18, 0x60, 0xee, 0xc4, 0x2e, 0x6b, 0x7f, 0x4b, 0xb9, 0x28, 0x6a,
	0x2f, 0xcf, 0x12, 0xcb, 0x28, 0x13, 0xaa, 0xf6, 0x55, 0x57, 0x9d, 0xd1, 0xff, 0x80, 0xe2, 0x34,
	0x16, 0x31, 0x4e, 0x3c, 0x1f, 0x07, 0x0b, 0x3a, 0x9f, 0x7b, 0x4b, 0x6e, 0x95, 0x15, 0xa3, 0xa3,
	0x2d, 0xc3, 0xdc, 0xf0, 0x96, 0xa3, 0x7f, 0xc0, 0x5c, 0xe2, 0x07, 0x8f, 0x11, 0xc1, 0x62, 0x22,
	0x9f, 0x42, 0xd2, 0x60, 0x89, 0x1f, 0xdc, 0x1c, 0xe9, 0x4e, 0xa1, 0xf5, 0x38, 0x75, 0x74, 0x0c,
	0x90, 0x31, 0x7a, 0x47, 0x02, 0xe1, 0xc5, 0xa1, 0x0e, 0xa7, 0xa1, 0x91, 0x49, 0x28, 0xcd, 0x21,
	0x16, 0x98, 0x13, 0x65, 0x2e, 0xe5, 0x66, 0x8d, 0x4c, 0xc2, 0xee, 0xb7, 0x32, 0xb4, 0x7f, 0xc8,
	0x1e, 0xfd, 0x07, 0x6d, 0x9f, 0x52, 0xc1, 0x05, 0xc3, 0x99, 0x27, 0x13, 0xe3, 0x5a, 0xb6, 0xb5,
	0x81, 0x2f, 0x25, 0xfa, 0x64, 0xbe, 0x5d, 0xa8, 0x2f, 0xc8, 0x9a, 0x67, 0x38, 0x20, 0x2a, 0xcb,
	0x86, 0xbb, 0xb9, 0xcb, 0x58, 0x04, 0xf6, 0x13, 0xe2, 0xa9, 0xae, 0xad, 0xe4, 0xb1, 0x28, 0x64,
	0x2a, 0x5b, 0xf7, 0x0e, 0x7e, 0x63, 0x24, 0x4b, 0xe2, 0x40, 0x75, 0xbb, 0x47, 0x75, 0x3f, 0x56,
	0x55, 0x3f, 0xbe, 0xf8, 0xe5, 0xab, 0xd9, 0xee, 0xd6, 0xf9, 0x5d, 0xee, 0x3b, 0x4e, 0x05, 0x5b,
	0xbb, 0x88, 0xed, 0x19, 0xd0, 0x39, 0x98, 0x21, 0x99, 0xe3, 0x55, 0x22, 0x3c, 0x21, 0x12, 0xeb,
	0x50, 0x75, 0xc6, 0x5f, 0x76, 0x3e, 0x7a, 0x76, 0x31, 0x7a, 0xf6, 0x48, 0x8f, 0x9e, 0x0b, 0x9a,
	0x7d, 0x2d, 0x12, 0xd4, 0x03, 0xf3, 0x9e, 0x30, 0x1e, 0xd3, 0x34, 0x21, 0x9c, 0x5b, 0xb5, 0x9e,
	0xd1, 0xaf, 0xbb, 0xbb, 0x90, 0x64, 0x04, 0x34, 0xe5, 0x31, 0x17, 0x24, 0x0d, 0xd6, 0x56, 0x5d,
	0x65, 0xba, 0x0b, 0x75, 0xc7, 0xf0, 0xe7, 0x4f, 0xc2, 0x45, 0x1d, 0x28, 0x2f, 0xc8, 0x5a, 0x97,
	0x5c, 0x1e, 0xd1, 0xef, 0x50, 0xbd, 0xc7, 0xc9, 0x8a, 0xe8, 0xe7, 0xcb, 0x2f, 0xe7, 0xa5, 0xe7,
	0x46, 0xf7, 0x06, 0x9a, 0xbb, 0x53, 0x89, 0x2c, 0xa8, 0xe9, 0xa7, 0xd7, 0xc5, 0x2f, 0xae, 0x4f,
	0xee, 0x0a, 0x0b, 0x6a, 0x3a, 0x6a, 0xad, 0x5c, 0x5c, 0x4f, 0x5f, 0x42, 0x63, 0xb3, 0x27, 0x90,
	0x09, 0xb5, 0xc9, 0xf4, 0x66, 0xf0, 0x66, 0x32, 0xea, 0x1c, 0xa0, 0x06, 0x54, 0xdd, 0xf1, 0x68,
	0x32, 0xeb, 0x18, 0xa8, 0x09, 0xf5, 0xe1, 0xe4, 0xd5, 0xd5, 0x87, 0xb1, 0xfb, 0xb1, 0x53, 0x42,
	0x47, 0xd0, 0xb8, 0x18, 0xcc, 0x66, 0x83, 0xe9, 0xc8, 0x1d, 0x74, 0xca, 0xc3, 0x3a, 0x1c, 0xe6,
	0x53, 0x37, 0x9c, 0xc0, 0xce, 0x76, 0x1b, 0x82, 0xd2, 0x7d, 0x2f, 0x0b, 0xfc, 0xc9, 0x89, 0x62,
	0x71, 0xbb, 0xf2, 0xed, 0x80, 0x2e, 0x9d, 0x88, 0xde, 0x91, 0x85, 0x93, 0xaf, 0x47, 0x1e, 0x2e,
	0x9c, 0x88, 0xe6, 0x0b, 0x90, 0x3b, 0xdb, 0x95, 0xe9, 0x1f, 0x2a, 0xe8, 0xd9, 0xf7, 0x00, 0x00,
	0x00, 0xff, 0xff, 0x65, 0x5a, 0xb3, 0xd3, 0x47, 0x05, 0x00, 0x00,
}
